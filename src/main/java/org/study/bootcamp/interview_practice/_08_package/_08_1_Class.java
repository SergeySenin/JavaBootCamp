/*

Пакет (package) — это механизм организации классов и интерфейсов в логические группы.
По своей сути, это просто папка (директория) на вашем жёстком диске,
которая содержит сгруппированные файлы .java и скомпилированные файлы .class.

Зачем нужны пакеты?
Избежание конфликтов имён (пространства имён)
Организация кода по логическим группам
Контроль доступа (видимость в пределах пакета)
Сокрытие реализации (инкапсуляция)
Повторное использование кода

Именование пакетов
Обратный домен: com.company.project
Только строчные буквы
Пример: org.apache.commons
 */

package org.study.bootcamp.interview_practice._08_package;

/*
Импорты
Использование классов из других пакетов:
import java.util.List;                  конкретный класс
import java.util.*;                     все классы пакета (не рекомендуется)
import static java.lang.Math.PI;        статический импорт

Без импорта — через полное имя:
java.util.ArrayList list = new java.util.ArrayList();
 */

// ...ЗДЕСЬ БУДУТ ИМПОРТЫ...

/*
модификатор доступа Класс имяКласса {                    Базовое объявление класса

}

 */

public class _08_1_Class {

 // Константы                                        Константа и статическое поле
 // Статические поля                                 объявляются в начале класса

 // модификаторДоступа тип имяПоля;                  Объявление поля внутри класса

 // модификаторДоступа тип имяПоля = значение;       Объявление поля с инициализацией


 // модификаторДоступа ИмяКласса(тип параметр) { Конструктор с параметром
 // this.поле = параметр;                        Инициализация полей объекта
 // }
 //
 //                              Конструктор по умолчанию (без параметров) — ...
 //                              Перегруженный конструктор (overloading) — ...
 //                              Конструктор копирования (copy constructor) — ...


    // Метод без параметров и возврата
 // модификаторДоступа void имяМетода() {                           void - метод ничего не возвращает
 // действия без возврата результата
 // }

    // Метод с параметрами
 // модификаторДоступа тип имяМетода(тип параметр1, тип параметр2) {
 // использование параметров
 // результат = параметр1 и параметр2;                              Работа с параметрами
 // return результат;                                               Возврат значения типа "тип"
 // }

    // Перегруженные методы (overloading)
 // модификаторДоступа тип имяМетода(тип параметр) {     Версия с одним параметром
 // return значение;
 // }
 //
 // модификаторДоступа тип имяМетода(тип п1, тип п2) {   Версия с двумя параметрами
 // return другоеЗначение;                               Такое же имя, но разные параметры
 // }


    // Метод с возвращаемым значением
 // [модификаторы] тип имяМетода() {                     Возвращаемый тип указан
 // вычисления
 // return значение;                                     Обязательно вернуть значение типа "тип"
 // }

    // Статический метод
 // модификаторДоступа static тип имяМетода(параметры) { static - метод принадлежит классу
 // логика, не зависящая от состояния объекта
 // return значение;                                     Вызывается через ИмяКласса.метод()
 // }

    // Рекурсивный метод
 // модификаторДоступа тип имяМетода(параметр) {
 // if (условиеЗавершения) {                             Базовый случай
 // return конечноеЗначение;
 // }
 // return имяМетода(изменённыйПараметр);                Рекурсивный вызов
 // }


 // Класс имяОбъекта = new Класс();                      Создание объекта (экземпляра класса)
 // имяОбъекта.метод();                                  Вызов метода объекта
}
