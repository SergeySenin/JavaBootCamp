package org.study.bootcamp.interview_practice;

//  ИЕРАРХИЯ JAVA-ПЛАТФОРМЫ
// ────────────────────────────────────────────
//
//      ┌─────────────────────────────────────┐
//      │                 JDK                 │  ← Java Development Kit     | Полный комплект для разработки,
//      │    ┌───────────────────────────┐    │                               включающий JRE и инструменты разработки
//      │    │            JRE            │    │  ← Java Runtime Environment | Среда выполнения,
//      │    │    ┌─────────────────┐    │    │                               содержащая JVM и базовые библиотеки
//      │    │    │       JVM       │    │    │  ← Java Virtual Machine     | Виртуальная машина,
//      │    │    │   ┌─────────┐   │    │    │                               выполняющая байт-код
//      │    │    │   │ЗАГРУЖАЕТ│   │    │    │
//      │    │    │   │ БАЙТ-КОД│   │    │    │
//      │    │    │   │  .class │   │    │    │
//      │    │    │   └─────────┘   │    │    │
//      │    │    │  ┌───────────┐  │    │    │
//      │    │    │  │ УПРАВЛЯЕТ │  │    │    │
//      │    │    │  │  ПАМЯТЬЮ  │  │    │    │
//      │    │    │  │   ПРОЦЕССА│  │    │    │
//      │    │    │  └───────────┘  │    │    │
//      │    │    └─────────────────┘    │    │
//      │    │                           │    │
//      │    │    ┌─────────────────┐    │    │
//      │    │    │    БИБЛИОТЕКИ   │    │    │  ← Готовые компоненты для работы с вводом-выводом, сетями и так далее
//      │    │    └─────────────────┘    │    │
//      │    └───────────────────────────┘    │
//      │                                     │
//      │    ┌───────────────────────────┐    │
//      │    │   ИНСТРУМЕНТЫ РАЗРАБОТКИ  │    │  ← Компилятор javac (исходный код файла .java -> байт-код файла .class),
//      │    └───────────────────────────┘    │    отладчик (jdb), архиватор (jar), документация (javadoc), и так далее
//      └─────────────────────────────────────┘


//  ПАМЯТЬ JVM
// ──────────────────────────────────────────────────────────
//                                                            Стек (Stack):
// ┌─────────────────┐    ┌─────────────────────────────────┐ - область памяти конкретного потока;
// │       СТЕК      │    │              КУЧА               │ - хранит кадры вызовов методов (stack frame) и
// │       (Stack)   │    │              (Heap Memory)      │   внутри кадра: параметры метода, локальные переменные
// ├─────────────────┤    ├─────────────────────────────────┤   (примитивы и ссылки), служебная информация;
// │                 │    │                                 │ - принцип LIFO: последний вошёл — первый вышел
// │ Быстрое         │    │ Динамическое                    │
// │ выделение       │    │ распределение                   │ Куча (Heap):
// │ LIFO порядок    │    │                                 │ - общая область памяти для всех потоков;
// │                 │    │ ┌─────────────────────────┐     │ - хранит все объекты и в объектах хранятся
// │ int x = 10;     │    │ │ Молодое поколение       │     │   как примитивные поля, так и ссылочные поля
// │ ○──────────○    │    │ │ (Young Generation)      │     │
// │ │ x: 10    │    │    │ └─────────────────────────┘     │ Где что хранится:
// │ ○──────────○    │    │ ┌─────────────────────────┐     │ - Локальный примитивный тип →
// │ String string ──┼────┼─▶ Объект String           │     │                              значение в стеке
// │ ○────────────○  │    │ │ value: "Hello!"         │     │ - Локальный ссылочный тип →
// │                 │    │ │ методы...               │     │                            ссылка в стеке,
// └─────────────────┘    │ └─────────────────────────┘     │                            объект — в куче
//                        │ ┌─────────────────────────┐     │ - Поле примитивного типа →
//                        │ │ Старое поколение        │     │                           часть объекта в куче
//                        │ │ (Old Generation)        │     │ - Поле ссылочного типа →
//                        │ └─────────────────────────┘     │                         ссылка внутри объекта в куче,
//                        └─────────────────────────────────┘                         целевой объект тоже в куче
//         ↑                              ↑
//         │                              │
// AUTOMATIC              GARBAGE COLLECTOR
// (автоматическая        (сборщик мусора)
// очистка при            периодически проверяет кучу
// выходе из метода)      и удаляет объекты без ссылок


//  РАБОТА СБОРЩИКА МУСОРА В КУЧЕ
// ───────────────────────────────────────────────────────
//                                                         String Pool:
// ┌─────────────────────────────────────────────────────┐ - специальная таблица в куче для строковых литералов и строк;
// │                         КУЧА                        │ - для одинаковых текстов возвращается тот же объект String;
// │                                                     │ - экономит память и ускоряет сравнение строк (==) литералов
// │    ┌───────────────────────────────────────────┐    │
// │    │                    ПУЛЫ                   │    │ Integer Pool (и аналогичные):
// │    │    ┌─────────────┐ ┌─────────────────┐    │    │ - кэш объектов-обёрток для небольшого диапазона значений;
// │    │    │ String Pool │ │ Integer Pool    │    │    │ - по умолчанию кэшируется диапазон [-128; 127];
// │    │    │ "Hello"     │ │ Integer(11)     │    │    │ - при автобоксинге числа из этого диапазона
// │    │    │ "World"     │ │ Integer(22)     │    │    │   могут возвращать один и тот же объект
// │    │    └─────────────┘ └─────────────────┘    │    │
// │    └───────────────────────────────────────────┘    │ Строку сделали объектом для того, чтобы можно было хранить и
// │                                                     │ данные (символы) и методы для работы с ними (substring), и
// │    ┌───────────────────────────────────────────┐    │ метаданные (кодировку, хэш), и чтобы всё это могло
// │    │             МОЛОДОЕ ПОКОЛЕНИЕ             │    │ участвовать в объектной модели языка — жить в куче, попадать
// │    │    ┌─────────────┐ ┌─────────────────┐    │    │ в коллекции и управляться сборщиком мусора
// │    │    │    Eden     │ │     Survivor    │    │    │ - строка — это последовательность символов
// │    │    │             │ │     (S0 и S1)   │    │    │   + поведение (методы работы со строками);
// │    │    │    (новые   │ │     (выжившие   │    │    │ - создаётся, например:
// │    │    │    объекты) │ │     объекты)    │    │    │   String s1 = "Hello"; | литерал, попадает в String Pool
// │    │    └─────────────┘ └─────────────────┘    │    │   String s2 = new String("Hello"); | новый объект в куче
// │    └───────────────────────────────────────────┘    │   String s2 = new String("Hello"); | новый объект в куче
// │                        ║                            │ String s3 = s1.intern(); | получить объект из пула;
// │    ┌───────────────────────────────────────────┐    │ - иммутабельность (immutable):
// │    │              СТАРОЕ ПОКОЛЕНИЕ             │    │   * внутреннее содержимое нельзя изменить после создания;
// │    │    ┌─────────────────────────────────┐    │    │   * "изменяющие" методы (replace, toUpperCase и так далее)
// │    │    │  Долгоживущие объекты           │    │    │     создают новый объект, а не изменяют начальный;
// │    │    │  (пережившие несколько сборок)  │    │    │   * даёт потокобезопасность при чтении, удобный пул строк
// │    │    └─────────────────────────────────┘    │    │
// │    └───────────────────────────────────────────┘    │
// │                                                     │
// └─────────────────────────────────────────────────────┘

/**
 * КЛАСС ДЛЯ ДЕМОНСТРАЦИИ ТИПОВ ДАННЫХ В JAVA И ИХ ОСОБЕННОСТЕЙ
 *
 * @author Sergey
 */
public class DataTypes {

    // === ПРИМИТИВНЫЕ ТИПЫ ДАННЫХ ===
    // 0) Для представления "сырых" чисел, символов и логики
    // 1) Хранят непосредственно значение
    // 2) Имеют фиксированный размер в памяти
    // 3) Всегда имеют значение
    //    (не могут быть null, компилятор не позволяет;
    //    локальные переменные должны быть явно
    //    инициализированы перед использованием,
    //    а поля классов имеют значения по умолчанию)
    // 4) Сравниваются по значению
    //    (оператор == сравнивает значения)
    // 5) Работают быстрее ссылочных типов и занимают меньше памяти
    //
    //  ПРИМИТИВНЫЙ ТИП (int)
    // ─────────────────────────────────────
    // Локальная переменная: int number = 128
    //              │
    //              └───▶ Непосредственно значение 128
    //                    (хранится в стеке)
    //
    // Размер: всегда 32 бита (4 байта)
    // Сравнение:
    // int number = 128;                 | number == 128 → true (по значению)
    // int a = 128; int b = 128;         | a == b → true (по значению)
    // int a = 128; Integer b = 128;     | a == b → true (b распаковывается в int)


    // Целочисленные типы
    private byte byteValue;                               // 8-битное целое число (-128 до 127)
    private short shortValue;                             // 16-битное целое число (-32,768 до 32,767)
    private int intValue;                                 // 32-битное целое число (-2^31 до 2^31-1)
    private long longValue;                               // 64-битное целое число (-2^63 до 2^63-1)

    // Типы с плавающей точкой
    private float floatValue;                             // 32-битное число с плавающей точкой
    private double doubleValue;                           // 64-битное число с плавающей точкой

    // Символьный тип
    private char charValue;                               // 16-битный Unicode символ

    // Логический тип
    private boolean booleanValue;                         // true или false


    // === ССЫЛОЧНЫЕ ТИПЫ ДАННЫХ ===
    // 0) Для всего, что сложнее примитивов:
    //    строки, объекты, массивы, коллекции, сущности предметной области.
    // 1) Хранят ссылку на объект в куче
    // 2) Ссылка всегда фиксированного размера,
    //    а размер объекта в куче может отличаться
    // 3) Могут иметь значение null (отсутствие объекта)
    // 4) Оператор == сравнивает ссылки
    //    (один и тот же объект или нет),
    //    метод equals() обычно сравнивает значение
    //    (поведение можно переопределить)
    // 5) Поддерживают вызов методов
    //
    //  ССЫЛОЧНЫЙ ТИП (Integer)
    // ─────────────────────────────────────
    // Локальная переменная: Integer number = 128
    //              │
    //              └───▶ [ССЫЛКА] ────▶ ОБЪЕКТ Integer
    //                              │    ┌─────────────┐
    //                              │    │ value: 128  │
    //                              │    │ методы...   │
    //                              │    └─────────────┘
    //                              │    (хранится в куче)
    //                              │
    // Может быть: number = null (ссылка никуда не ведёт)
    //
    // Размер: переменная + объект + накладные расходы
    // Сравнение:
    // Integer number = 128;              | number == 128 → true (автораспаковка)
    // Integer a = 3; Integer b = 3;      | a == b → true (кэш Integer [-128..127])
    // Integer a = 128; Integer b = 128;  | a == b → false (как правило, разные объекты)
    // Integer a = 128; Integer b = 128;  | a.equals(b) → true (значения равны)


    // В Java примитивные типы могут автоматически превращаться в классы-обёртки,
    // и наоборот. Это называется автоупаковка (autoboxing) и автораспаковка (unboxing)

    // Классы-обёртки полезны, когда нужно хранить примитивные типы в коллекциях
    // Позволяют использовать дополнительные методы


    // === ССЫЛОЧНЫЕ ТИПЫ — ОБЁРТКИ ДЛЯ ПРИМИТИВНЫХ ТИПОВ ===

    // Обёртки для целочисленных типов
    private Byte byteWrapper;                             // Обёртка для byte
    private Short shortWrapper;                           // Обёртка для short
    private Integer integerWrapper;                       // Обёртка для int
    private Long longWrapper;                             // Обёртка для long

    // Обёртки для типов с плавающей точкой
    private Float floatWrapper;                           // Обёртка для float
    private Double doubleWrapper;                         // Обёртка для double

    // Обёртки для символьного и логического типов
    private Character characterWrapper;                   // Обёртка для char
    private Boolean booleanWrapper;                       // Обёртка для boolean


    // === КЛЮЧЕВОЕ СЛОВО FINAL ===
    private final double PI = 3.14159;                    // Значение PI теперь неизменно
                                                          // Константы всегда пишутся ЗАГЛАВНЫМИ БУКВАМИ (PI)


    // === КЛЮЧЕВОЕ СЛОВО STATIC ===
    private static int instanceCount;                     // Член класса, а не объекта
                                                          // Доступен без создания объекта
                                                          // Существует в единственном экземпляре


    // === ССЫЛОЧНЫЕ ТИПЫ — СТРОКИ И ОБЪЕКТЫ ===

    private String stringValue;                           // Строка (иммутабельный класс)
    private Object objectValue;                           // Базовый класс всех объектов
    private StringBuilder stringBuilder;                  // Мутабельный класс для работы со строками
    private StringBuffer stringBuffer;                    // Потокобезопасный мутабельный класс для строк


    // И так далее:
    // === МАССИВЫ ===
    // === КОЛЛЕКЦИИ ===
    // Классы и их объекты (включая собственные классы пользователя)
    // Интерфейсы (переменная интерфейсного типа хранит ссылку на объект-класс-реализацию)
    // Перечисления enum (каждое значение enum — объект)
    // Записи record (ссылочный тип, объект в куче)
    // Аннотации (runtime-аннотации представлены объектами)
    // Все исключения и ошибки (Throwable и наследники)
    // Функциональные объекты: лямбды и ссылки на методы (реализуются как объекты)
}
